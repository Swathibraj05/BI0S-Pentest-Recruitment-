# CODING CHALLENGE

1. [HACKERRANK QUESTIONS](https://docs.google.com/document/d/1v552UAO5ypoayJeChmzjRC_NoqAxURul/edit?usp=sharing&ouid=114136219732784345709&rtpof=true&sd=true)

2) Make a one line python program to find whether the given year is leap or not.
   
`year=int(input("enter year:"))`

`print("leap year" if ((year%4==0) or (year%100!=0) and (year%400==0)) else "it is not a leap year")`

Challenge description:
We were asked to make a one line python program to find whether the given year is leap or not.

Approach:
A leap year is divisible by 4 and 400 or a year divisble by 100 and 400. so used if-else block which satisfies this condition.
if the condition satisfies, it will give "leap year" as the output. Otherwise, "it is not a leap year" as the output.


Chat app
`import socket
import hashlib
import hmac
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives.padding import PKCS7

def derive_key(password, salt):
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA512(),
        iterations=100000,
        salt=salt.encode(),
        length=32
    )
    key = kdf.derive(password.encode())
    return key

def aes_encrypt(message, key):
    cipher = Cipher(algorithms.AES(key), modes.ECB(), backend=default_backend())
    encryptor = cipher.encryptor()
    padder = PKCS7(128).padder()
    padded_message = padder.update(message) + padder.finalize()
    ciphertext = encryptor.update(padded_message) + encryptor.finalize()
    return ciphertext

def aes_decrypt(ciphertext, key):
    cipher = Cipher(algorithms.AES(key), modes.ECB(), backend=default_backend())
    decryptor = cipher.decryptor()
    decrypted_message = decryptor.update(ciphertext) + decryptor.finalize()
    return decrypted_message.rstrip(b"\0")  # Remove PKCS7 padding

def authenticate(data, key):
    received_message, received_hmac = data[:-64], data[-64:]
    calculated_hmac = hmac.new(key, received_message, hashlib.sha512).digest()
    return hmac.compare_digest(received_hmac, calculated_hmac)

def start_server():
    password = "your_password"
    salt = "your_salt"
    server_port = 50001

    key = derive_key(password, salt)

    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_socket:
        try:
            server_socket.bind(('localhost', server_port))
            print(f'Server is binding to port {server_port}')
        except Exception as bind_error:
            print(f'Error binding to port {server_port}: {bind_error}')
            return

        server_socket.listen(1)
        print(f'Server is listening on port {server_port}')

        client_socket, client_address = server_socket.accept()
        print('Accepted connection from', client_address)

        while True:
            data = client_socket.recv(1024)
            if not data:
                break

            if authenticate(data, key):
                decrypted_message = aes_decrypt(data[:-64], key)
                print("Received message:", decrypted_message.decode())

                reply = input("Enter your reply: ")
                encrypted_reply = aes_encrypt(reply.encode(), key)
                hmac_reply = hmac.new(key, encrypted_reply, hashlib.sha512).digest()
                client_socket.sendall(encrypted_reply + hmac_reply)
            else:
                print("Authentication failed. Possible tampering detected.")

if __name__ == "__main__":
    start_server()`
